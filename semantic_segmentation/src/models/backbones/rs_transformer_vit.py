"""Implement Transformer Class for RSFomer

"""

import math
import paddle
import warnings
import paddle.nn as nn
from einops import rearrange
import paddle.nn.functional as F
from src.models.backbones.swin_transformer import Identity, DropPath, Mlp


def _no_grad_trunc_normal_(tensor, mean, std, a, b):
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function  计算标准正态累积分布函数
        return (1. + math.erf(x / math.sqrt(2.))) / 2.

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn("mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
                      "The distribution of values may be incorrect.",
                      stacklevel=2)

    with paddle.no_grad():
        # Values are generated by using a truncated uniform distribution and
        # then using the inverse CDF for the normal distribution.
        # Get upper and lower cdf values
        l = norm_cdf((a - mean) / std)
        u = norm_cdf((b - mean) / std)

        # Uniformly fill tensor with values from [l, u], then translate to
        # [2l-1, 2u-1].
        tensor = paddle.uniform(shape=tensor.shape, min=2 * l - 1, max=2 * u - 1)

        # Use inverse cdf transform for normal distribution to get truncated
        # standard normal
        tensor = tensor.erf()

        # Transform to proper mean, std
        tensor = tensor.multiply(paddle.to_tensor(std * math.sqrt(2.)))
        tensor = tensor.add(paddle.to_tensor(mean))

        # Clamp to ensure it's in the proper range
        tensor = tensor.clip(min=a, max=b)
        return tensor


# 用于上采样
class PatchExpand(nn.Layer):
    def __init__(self, input_resolution, dim, dim_scale=2, norm_layer=nn.LayerNorm):
        super().__init__()
        self.input_resolution = input_resolution #(16, 16),(32, 32),(64, 64)
        self.dim = dim
        self.expand = nn.Linear(dim, 2 * dim) if dim_scale == 2 else nn.Identity()
        self.norm = norm_layer(dim // dim_scale)

    def forward(self, x):
        """
        x: B, H*W, C
        """
        H ,W = self.input_resolution
        # print("self.expand",self.expand) #Linear(in_features=512, out_features=1024)
        # print("x",x) #shape=[8, 256, 512]
        x = self.expand(x)
        B, L, C = x.shape
        assert L == H * W, "input feature has wrong size"

        x = x.reshape([B, H, W, C])
        # print("x2", x)  #shape=[8, 16, 16, 1024]
        # x = x.view(B, H, W, C)
        x = x.numpy() #转换一下，因为这个函数不支持paddle-tensor
        x = rearrange(x, 'b h w (p1 p2 c)-> b (h p1) (w p2) c', p1=2, p2=2, c=C // 4)  # p1xp2xc = C
        # print("x3",x.shape, x)  # shape=[8, 32, 32, 256]

        x = paddle.to_tensor(x) # shape=[8, 32, 32, 256]
        x = x.reshape([B, -1, C // 4]) # shape=[8, 1024, 256]通道缩减了2倍，上采用2倍
        # x = x.view(B, -1, C // 4)
        x = self.norm(x)

        return x


# 截断正态分布
def trunc_normal_(tensor, mean=0., std=1., a=-2., b=2.):
    # type: (Tensor, float, float, float, float) -> Tensor
    r"""Fills the input Tensor with values drawn from a truncated
    normal distribution. The values are effectively drawn from the
    normal distribution :math:`\mathcal{N}(\text{mean}, \text{std}^2)`
    with values outside :math:`[a, b]` redrawn until they are within
    the bounds. The method used for generating the random values works
    best when :math:`a \leq \text{mean} \leq b`.
    Attributes:
        tensor: an n-dimensional `paddle.Tensor`
        mean: the mean of the normal distribution
        std: the standard deviation of the normal distribution
        a: the minimum cutoff value
        b: the maximum cutoff value
    Examples:
        >>> w = paddle.empty([3, 5])
        >>> trunc_normal_(w)
    """
    return _no_grad_trunc_normal_(tensor, mean, std, a, b)


def expand(x, nclass):
    return x.unsqueeze(1).tile([1, nclass, 1, 1, 1]).flatten(0, 1)


class Attention_Encoder(nn.Layer):
    """Attention Encoder Implement

    multi-head self-attention module

    Attributes:
        dim: int, input dimension (channels)
        num_heads: int, number of attention heads
        qkv_bias: bool, if True, enable learnable bias to q,k,v, default: False
        qk_scale: float, override default qk scale head_dim**-0.5 if set, default: None
        attn_drop: float, dropout of attention
        proj_drop: float, dropout for output
    """

    def __init__(self, dim, num_heads=8, qkv_bias=False, qk_scale=None, attn_drop=0., proj_drop=0.):
        super().__init__()
        self.num_heads = num_heads
        head_dim = dim // num_heads
        # NOTE scale factor was wrong in my original version, can set manually to be compat with prev weights
        self.scale = qk_scale or head_dim ** -0.5

        self.qkv = nn.Linear(dim, dim * 3, bias_attr=qkv_bias)
        self.attn_drop = nn.Dropout(attn_drop)
        self.proj = nn.Linear(dim, dim)
        self.proj_drop = nn.Dropout(proj_drop)

    def forward(self, x):
        B, N, C = x.shape
        # qkv shape [3, N, num_head, HW, C//num_head]
        qkv = self.qkv(x).reshape([B, N, 3, self.num_heads, C // self.num_heads]).transpose([2, 0, 3, 1, 4])
        q, k, v = qkv[0], qkv[1], qkv[2]  # [N, num_head, HW, C//num_head]
        attn = (q @ k.transpose([0, 1, 3, 2])) * self.scale
        attn = F.softmax(attn, axis=-1)
        attn = self.attn_drop(attn)
        x = (attn @ v).transpose([0, 2, 1, 3]).reshape([B, N, C])
        x = self.proj(x)
        x = self.proj_drop(x)
        return x


class Attention_Decoder(nn.Layer):
    """Attention Decoder Implement

    Attributes:
        dim: int, input dimension (channels)
        num_heads: int, number of attention heads
        qkv_bias: bool, if True, enable learnable bias to q,k,v, default: False
        qk_scale: float, override default qk scale head_dim**-0.5 if set, default: None
        attn_drop: float, dropout of attention
        proj_drop: float, dropout for output
    """

    def __init__(self, dim, num_heads=1, qkv_bias=False, qk_scale=None, attn_drop=0., proj_drop=0.):
        super().__init__()
        self.num_heads = num_heads
        head_dim = dim // num_heads
        # NOTE scale factor was wrong in my original version, can set manually to be compat with prev weights
        self.scale = qk_scale or head_dim ** -0.5

        self.fc_q = nn.Linear(dim, dim * 1, bias_attr=qkv_bias)
        self.fc_kv = nn.Linear(dim, dim * 2, bias_attr=qkv_bias)

        self.attn_drop = nn.Dropout(attn_drop)
        self.proj = nn.Linear(dim, dim)
        self.proj_drop = nn.Dropout(proj_drop)

    def forward(self, q, x):
        # q:[B,12,256] x:[B,HW,256]
        B, N, C = x.shape
        n_class = q.shape[1]

        q = self.fc_q(q).reshape([B, self.num_heads, n_class, C // self.num_heads])
        kv = self.fc_kv(x).reshape([B, N, 2, self.num_heads, C // self.num_heads]).transpose([2, 0, 3, 1, 4])
        k, v = kv[0], kv[1]  # [B, num_head, HW, 256/num_head]

        attn1 = (q @ k.transpose([0, 1, 3, 2])) * self.scale  # [B, num_head, 6, HW]
        attn2 = F.softmax(attn1, axis=-1)
        attn3 = self.attn_drop(attn2)  # [B, num_head, 11, HW]

        x = (attn3 @ v).reshape([B, n_class, C])
        x = self.proj(x)
        x = self.proj_drop(x)  # [B, 12, 256]

        attn = attn1.transpose([0, 2, 1, 3])

        return attn, x


class Block_Encoder(nn.Layer):
    """Block Encoder Implement

    consists of a multi-head self-attention module and a feed forward network

    Attributes:
        dim: int, input dimension (channels)
        num_heads: int, number of attention heads
        mlp_ratio: float, ratio of mlp hidden dim and input embedding dim, default: 4.
        qkv_bias: bool, if True, enable learnable bias to q,k,v, default: False
        qk_scale: float, override default qk scale head_dim**-0.5 if set, default: None
        drop: dropout rate for Mlp module
        attn_drop: float, dropout of attention
        drop_path: drop path for stochastic depth
        act_layer: activation layer type, default: nn.GELU
        norm_layer: normalization layer type, default: nn.LayerNorm
    """

    def __init__(self, dim, num_heads, mlp_ratio=4., qkv_bias=False, qk_scale=None, drop=0., attn_drop=0.,
                 drop_path=0., act_layer=nn.GELU, norm_layer=nn.LayerNorm):
        super().__init__()
        self.norm1 = norm_layer(dim)
        self.attn = Attention_Encoder(
            dim, num_heads=num_heads, qkv_bias=qkv_bias, qk_scale=qk_scale, attn_drop=attn_drop, proj_drop=drop)
        # NOTE: drop path for stochastic depth, we shall see if this is better than dropout here
        self.drop_path = DropPath(drop_path) if drop_path > 0. else Identity()
        self.norm2 = norm_layer(dim)
        mlp_hidden_dim = int(dim * mlp_ratio)
        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, dropout=drop)

    def forward(self, x):
        x = x + self.drop_path(self.attn(self.norm1(x)))
        x = x + self.drop_path(self.mlp(self.norm2(x)))
        return x


class Block_Decoder(nn.Layer):
    """Block Decoder Implement

    Attributes:
        dim: int, input dimension (channels)
        num_heads: int, number of attention heads
        feat_HxW: control Mlp in_features dim
        mlp_ratio: float, ratio of mlp hidden dim and input embedding dim, default: 4.
        qkv_bias: bool, if True, enable learnable bias to q,k,v, default: False
        qk_scale: float, override default qk scale head_dim**-0.5 if set, default: None
        drop: float, dropout rate for Mlp module, default: 0.
        attn_drop: float, dropout rate of attention, default: 0.
        drop_path: float, drop path for stochastic depth, default: 0.
        act_layer: activation layer type, default: nn.GELU
        norm_layer: normalization layer type, default: nn.LayerNorm
    """

    def __init__(self, dim, num_heads, feat_HxW, mlp_ratio=4., qkv_bias=False, qk_scale=None, drop=0.,
                 attn_drop=0., drop_path=0., act_layer=nn.GELU, norm_layer=nn.LayerNorm):
        super().__init__()
        self.norm1 = norm_layer(dim)
        self.norm1_clsembed = norm_layer(dim)

        self.attn = Attention_Decoder(
            dim, num_heads=num_heads, qkv_bias=qkv_bias, qk_scale=qk_scale, attn_drop=attn_drop, proj_drop=drop)
        # NOTE: drop path for stochastic depth, we shall see if this is better than dropout here
        self.drop_path = DropPath(drop_path) if drop_path > 0. else Identity()
        self.norm2 = norm_layer(dim) #dim: 512,256,128,64
        self.norm3 = norm_layer(dim)
        self.norm4 = norm_layer(feat_HxW) #1024
        # print("feat_HxW",feat_HxW) #256(16x16),1024(32x32),4096(64x64),16384(128x128)

        mlp_hidden_dim = int(dim * mlp_ratio)
        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, dropout=drop)
        self.mlp2 = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, dropout=drop)
        self.mlp3 = Mlp(in_features=feat_HxW, hidden_features=feat_HxW * 3, dropout=drop)

    def forward(self, query, feat):
        # query:[B,6,256]  feat:[B,6,HW]
        attn, query = self.attn(self.norm1_clsembed(query), self.norm1(feat))
        query = query + self.drop_path(query)
        query = query + self.drop_path(self.mlp(self.norm2(query)))

        feat = feat + self.drop_path(feat)
        feat = feat + self.drop_path(self.mlp2(self.norm3(feat)))

        attn = attn + self.drop_path(attn)
        # print("attn",attn) #shape=[8, 6, 8, 256] shape=[8, 6, 8, 1024],
        attn = attn + self.drop_path(self.mlp3(self.norm4(attn)))

        return attn, query, feat


class TransformerEncoder(nn.Layer):
    """Transformer Encoder Implement

    Attributes:
        embed_dim: int, embedding dimension, embed_dim: 768
        depth: int, nums of Block_Encoder, default: 12
        num_patches: int, pos_embed dim, default: 32*32
        num_heads: int, number of attention heads, default: 12
        mlp_ratio: float, ratio of mlp hidden dim and input embedding dim, default: 4.
        qkv_bias: bool, if True, enable learnable bias to q,k,v, default: False
        qk_scale: float, override default qk scale head_dim**-0.5 if set, default: None
        drop_rate: float, rate of dropout, default: 0
        drop_path_rate: in order to implement stochastic depth decay rule, default: 0.
        attn_drop_rate: float, dropout rate of attention
        norm_layer: normalization layer type, default: nn.LayerNorm
    """

    # embed_dim=256, depth=4, num_heads=8,mlp_ratio=3
    def __init__(self, embed_dim=768, depth=12, num_patches=32 * 32, num_heads=12, mlp_ratio=4., qkv_bias=False,
                 qk_scale=None, drop_rate=0., drop_path_rate=0., attn_drop_rate=0., norm_layer=nn.LayerNorm):
        super().__init__()
        self.cls_token = paddle.create_parameter(shape=[1, 1, embed_dim], dtype='float32',
                                                 default_initializer=nn.initializer.Constant(0.0))
        self.pos_embed = paddle.create_parameter(shape=[1, num_patches + 1, embed_dim], dtype='float32',
                                                 default_initializer=nn.initializer.Constant(0.0))
        self.pos_drop = nn.Dropout(p=drop_rate)

        dpr = [x.item() for x in paddle.linspace(0, drop_path_rate, depth)]  # stochastic depth decay rule
        self.blocks_encoder = nn.LayerList([
            Block_Encoder(
                dim=embed_dim, num_heads=num_heads, mlp_ratio=mlp_ratio, qkv_bias=qkv_bias, qk_scale=qk_scale,
                drop=drop_rate, attn_drop=attn_drop_rate, drop_path=dpr[i], norm_layer=norm_layer)
            for i in range(depth)])

        self.norm = norm_layer(embed_dim)

        trunc_normal_(self.cls_token, std=.02)
        trunc_normal_(self.pos_embed, std=.02)
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                m.bias = paddle.create_parameter(shape=m.bias.shape, dtype='float32',
                                                 default_initializer=nn.initializer.Constant(value=0.0))
        elif isinstance(m, nn.LayerNorm):
            m.weight = paddle.create_parameter(shape=m.weight.shape, dtype='float32',
                                               default_initializer=nn.initializer.Constant(value=1.0))
            m.bias = paddle.create_parameter(shape=m.bias.shape, dtype='float32',
                                             default_initializer=nn.initializer.Constant(value=0.0))

    def resize_pos_embed(self, x, pos_embed):
        if x.shape[1] == pos_embed.shape[1]:
            return pos_embed

        n, hw, c = x.shape
        x_h = x_w = int(math.sqrt(hw - 1))
        assert x_h * x_w == hw - 1

        cls_pos_embed, feat_pos_embed = pos_embed[:, 0:1, :], pos_embed[:, 1:, :]
        feat_h = feat_w = int(math.sqrt(feat_pos_embed.shape[1]))
        assert feat_h * feat_w == feat_pos_embed.shape[1]
        feat_pos_embed = feat_pos_embed.reshape([feat_pos_embed.shape[0], feat_h, feat_w, -1]).transpose(
            [0, 3, 1, 2])  # [n,c,h,w]
        feat_pos_embed = F.interpolate(feat_pos_embed, (x_h, x_w), mode='bilinear', align_corners=True).transpose(
            [0, 2, 3, 1]) \
            .reshape([feat_pos_embed.shape[0], x_h * x_w, -1])

        new_pos_embed = paddle.concat([cls_pos_embed, feat_pos_embed], axis=1)
        assert new_pos_embed.shape[1] == x.shape[1]
        return new_pos_embed

    def forward_encoder(self, x):
        B = x.shape[0]
        cls_tokens = self.cls_token.expand([B, -1, -1])  # stole cls_tokens impl from Phil Wang, thanks
        x = paddle.concat((cls_tokens, x), axis=1)

        pos_embed = self.pos_embed
        pos_embed = self.resize_pos_embed(x, pos_embed)

        x = x + pos_embed
        x = self.pos_drop(x)
        for blk in self.blocks_encoder:
            x = blk(x)

        x = self.norm(x)
        return x[:, 0], x[:, 1:]


# class BasicLayer_up(nn.Layer):
#     """ A basic Swin Transformer layer for one stage.
#
#     Args:
#         dim (int): Number of input channels.
#         input_resolution (tuple[int]): Input resolution.
#         depth (int): Number of blocks.
#         num_heads (int): Number of attention heads.
#         window_size (int): Local window size.
#         mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.
#         qkv_bias (bool, optional): If True, add a learnable bias to query, key, value. Default: True
#         qk_scale (float | None, optional): Override default qk scale of head_dim ** -0.5 if set.
#         drop (float, optional): Dropout rate. Default: 0.0
#         attn_drop (float, optional): Attention dropout rate. Default: 0.0
#         drop_path (float | tuple[float], optional): Stochastic depth rate. Default: 0.0
#         norm_layer (nn.Module, optional): Normalization layer. Default: nn.LayerNorm
#         downsample (nn.Module | None, optional): Downsample layer at the end of the layer. Default: None
#         use_checkpoint (bool): Whether to use checkpointing to save memory. Default: False.
#     """
#
#     def __init__(self, dim, input_resolution, depth, ncalss, num_heads, window_size,
#                  mlp_ratio=4., qkv_bias=True, qk_scale=None, drop=0., attn_drop=0.,
#                  drop_path=0., norm_layer=nn.LayerNorm, upsample=None):
#
#         super().__init__()
#         self.dim = dim
#         self.input_resolution = input_resolution
#         self.depth = depth
#
#
#         # build blocks
#         self.blocks = nn.LayerList([
#             SwinTransformerBlock(dim=dim, input_resolution=input_resolution,
#                                  num_heads=num_heads, window_size=window_size,
#                                  shift_size=0 if (i % 2 == 0) else window_size // 2,
#                                  mlp_ratio=mlp_ratio,
#                                  qkv_bias=qkv_bias, qk_scale=qk_scale,
#                                  drop=drop, attn_drop=attn_drop,
#                                  drop_path=drop_path[i] if isinstance(drop_path, list) else drop_path,
#                                  norm_layer=norm_layer)
#             for i in range(depth)])
#
#         # patch merging layer
#         if upsample is not None:
#             self.upsample = PatchExpand(input_resolution, dim=dim, dim_scale=2, norm_layer=norm_layer)
#         else:
#             self.upsample = None
#
#     def forward(self, x):
#         for blk in self.blocks:
#             x = blk(x)
#         if self.upsample is not None:
#             x = self.upsample(x)
#         return x


class TransformerDecoder(nn.Layer):
    # embed_dim=256, depth=4, num_heads=8, mlp_ratio=3 ,decoder_feat_HxW = 256
    def __init__(self, input_size=512 // 4, embed_dim=256, depth=4, nclass=12,
                 decoder_feat_HxW=1024, num_heads=12, mlp_ratio=4.,
                 qkv_bias=False, qk_scale=None, drop_rate=0., drop_path_rate=0., attn_drop_rate=0.,  # 这一排的参数是默认的
                 norm_layer=nn.LayerNorm):
        super().__init__()

        self.cls_embed0 = paddle.create_parameter(shape=[1, nclass, embed_dim], dtype='float32',
                                                 default_initializer=nn.initializer.Constant(0.0))
        self.cls_embed1 = paddle.create_parameter(shape=[1, nclass, embed_dim * (2 ** (depth - 2))], dtype='float32',
                                                 default_initializer=nn.initializer.Constant(0.0))
        self.cls_embed2 = paddle.create_parameter(shape=[1, nclass, embed_dim * (2 ** (depth - 3))], dtype='float32',
                                                 default_initializer=nn.initializer.Constant(0.0))
        self.cls_embed3 = paddle.create_parameter(shape=[1, nclass, embed_dim * (2 ** (depth - 4))], dtype='float32',
                                                 default_initializer=nn.initializer.Constant(0.0))

        dpr = [x.item() for x in paddle.linspace(0, drop_path_rate, depth)]  # stochastic depth decay rule


        self.input_resolution = []
        self.concat_back_dim = nn.LayerList()
        self.patchExpand = nn.LayerList()
        for i_layer in range(depth):
            self.input_resolution.append(input_size // (2 ** (depth - 1 - i_layer)))  # 1/32, 1/16, 1/8, 1/4
            # concat_linear = nn.Linear(2 * int(embed_dim * 2 ** (depth - 1 - i_layer)),
            #                           int(embed_dim * 2 ** (depth - 1 - i_layer))) if i_layer > 0 else nn.Identity()

            concat_linear = nn.Linear(2 * embed_dim, embed_dim ) if i_layer > 0 else nn.Identity()
            # PatchExpand函数直接上采样2倍
            expand_layer= PatchExpand(input_resolution=(input_size // (2 ** (depth - i_layer)),
                                                        input_size // (2 ** (depth - i_layer))),
                                      dim=embed_dim * (2 ** (depth - i_layer)), dim_scale=2,
                        norm_layer=norm_layer) if i_layer > 0 else nn.Identity()

            self.concat_back_dim.append(concat_linear) # Identity(), linear512->256, 256->128, 128->64
            self.patchExpand.append(expand_layer) #Identity(), 512->256, 256->128, 128->64
        # print(" self.patchExpand", self.patchExpand)
        # print("self.input_resolution", self.input_resolution) # [16, 32, 64, 128]


        # print("self.upsample", self.upsample)
        self.upquery = nn.LayerList([
            nn.Identity(),
            nn.Linear(embed_dim * 8, embed_dim * 4),  # 512 -> 256
            nn.Linear(embed_dim * 4, embed_dim * 2),  # 256->128
            nn.Linear(embed_dim * 2, embed_dim * 1)]  # 128 ->64
        )

        self.blocks_decoder = nn.LayerList([
            Block_Decoder(
                dim=embed_dim,
                num_heads=num_heads, mlp_ratio=mlp_ratio, feat_HxW=decoder_feat_HxW, qkv_bias=qkv_bias,
                qk_scale=qk_scale,
                drop=drop_rate, attn_drop=attn_drop_rate, drop_path=dpr[i], norm_layer=norm_layer)
            for i in range(depth)])

        # print("self.blocks_decoder", self.blocks_decoder)
        # build decoder layers

        trunc_normal_(self.cls_embed0, std=.02)
        trunc_normal_(self.cls_embed1, std=.02)
        trunc_normal_(self.cls_embed2, std=.02)
        trunc_normal_(self.cls_embed3, std=.02)

        self.cls_embed = [self.cls_embed0,self.cls_embed1,self.cls_embed2,self.cls_embed3]
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                m.bias = paddle.create_parameter(shape=m.bias.shape, dtype='float32',
                                                 default_initializer=nn.initializer.Constant(value=0.0))
        elif isinstance(m, nn.LayerNorm):
            m.weight = paddle.create_parameter(shape=m.weight.shape, dtype='float32',
                                               default_initializer=nn.initializer.Constant(value=1.0))
            m.bias = paddle.create_parameter(shape=m.bias.shape, dtype='float32',
                                             default_initializer=nn.initializer.Constant(value=0.0))

    def forward_decoder(self, encoder_out):
        #encoder_out: shape=shape=[8, 256, 256] 全部都是这个大小 ,
        attns_list = []
        feat = encoder_out[3]   #[8,256,512]
        B = feat.shape[0]

        for idx, blk in enumerate(self.blocks_decoder): #0,1,2,3
            if idx == 0:
                query = self.cls_embed0.expand([B, -1, -1])  # shape=[8, 6, 256] 将可学习的类原型嵌入作为query, shape=[1, nclass, embed_dim]
            else:
                # query = self.upquery[idx](query)
                query += self.cls_embed0.expand([B, -1, -1])
                # feat = self.patchExpand[idx](feat) #上采样2倍，通道缩减2倍
                feat = paddle.concat([feat, encoder_out[3 - idx]], -1) #融入特征
                feat = self.concat_back_dim[idx](feat)  # 2*dim  -> dim #shape=[8, 256, 1024]
                # print("idx,feat", idx, feat.shape)

            attn, query, feat = blk(query, feat)
            attns_list.append(attn)
        # print("feat",feat.shape) # [8, 256, 256]
        # print("attns_list",attns_list[-1].shape) # [8, 6, 8, 256],[8, 6, 8, 256],[8, 6, 8, 256],[8, 6, 8, 256]
        return attns_list,feat  #attens_list[-1]  [8, 6, 8, 256] , feat [8, 256, 256]
